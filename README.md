# Как сделать неограниченный (или очень большой) allowance один раз и потом многократно списывать токены в рамках этого разрешения.


При классическом подходе с approve + transferFrom это выглядит так:

Пользователь делает approve(MetaTxSpender, очень_большая_сумма) — это одна транзакция с подтверждением в MetaMask.
Далее ваш контракт (MetaTxSpender в нашем примере) может неоднократно вызывать transferFrom(...) на любую нужную сумму, не превышающую allowance.
В случае мета-транзакций (как в нашей схеме с metaTransfer):

Пользователь всё так же один раз делает большое approve вашему мета-транзакционному контракту (если вы используете обычный ERC-20 без permit).
После этого каждая операция списания (каждые 60 секунд или по нажатию кнопки) происходит через metaTransfer(from, to, amount, nonce, v, r, s) — транзакцию отправляет «релэйер» (сервер), а пользователь только подписывает сообщение off-chain (или даже подписывает сразу набор сообщений).


Что такое offchain?
Off-chain подпись (signMessage или EIP-712) — это когда вы через MetaMask не посылаете транзакцию в блокчейн, а просто «подписываете» данные. Подпись делается приватным ключом локально (внутри MetaMask), а результат (v, r, s) остаётся «вне блокчейна», пока кто-то не отправит транзакцию с этой подписью в контракт.
Это отличается от обычной транзакции тем, что при подписи вы не платите газ и не меняете состояние сети; вы просто подтверждаете, что владеете таким-то адресом.
После этого подпись можно использовать в «мета-транзакции» (relay), или где-то ещё, чтобы совершать действия в сети (вызов смарт-контракта), но уже за счёт «релэйера» (который оплачивает газ).


В классическом ERC-20 без поддержки EIP-2612 всё равно нужна хотя бы одна обычная транзакция для approve(...). Но последующие вызовы transferFrom(...) можно инициировать «за кулисами» (например, контрактом или сторонним сервером).

More about it in chat with GPT: https://chatgpt.com/c/67b37070-2970-8008-a35d-5dd3389b0bc4